<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-2</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//TODO: Figure out how to stop the level from being reset when returning from tutorial screen! 

//set background 
script_execute(setBackground, global.backgroundType);

xOffset = room_width / 2 - ((TILE_SIZE * MAX_COLS) / 2);
yOffset = room_height / 2 - ((TILE_SIZE * MAX_ROWS) / 2);

//level data
level = 0;
playerRow = 0;
playerPos = 0;
turnCount = 0;
tilesCrushed = 0;
totalTiles = 0;


//buttons
tutorialButton = instance_create(room_width / 3 - 60, room_height - 120, tutorialBtnObj);
bgmButton = instance_create(tutorialButton.x + 150, room_height - 120, bgmBtnObj);
backButton = instance_create(bgmButton.x + 150, room_height - 120, levelBtnObj);
restartButton = instance_create(backButton.x + 150, room_height - 120, restartBtnObj);

levelGrid = ds_grid_create(MAX_ROWS, MAX_COLS);
levelCopy = ds_grid_create(MAX_ROWS, MAX_COLS);     //used to reset level
targetGrid = ds_grid_create(MAX_ROWS, MAX_COLS);    //target tile data
tileGrid = ds_grid_create(MAX_ROWS, MAX_COLS);      //holds instances of tiles.
boolGrid = ds_grid_create(MAX_ROWS, MAX_COLS);      //used to check where the ball is and to prevent rapid tile switching

//text colour TODO: make colors pulsate, this is for polish.
durableColor = color_get_value(c_blue);

//game states
levelComplete = false;
levelFailed = false;
timerActivated = false;
alarm[0] = 0;
alarm[4] = 0;             //used to display BGM title.
showMinusOne = false;
minusOneLocX = 0;
minusOneLocY = 0;
minusOneAlpha = 1;
deltaY = 10;                //used to scroll the win/loss labels after terminating state is reached.
levelsUnlocked = false;     //if true, 5 more levels are unlocked.
exitingLevel = false;       //used to prevent the exit code in the Begin Step from executing more than once.
bgmChanged = false;
trackName = "";
bgmAlpha = 1;
soundPlaying = false;       //prevents SFX from playing multiple times.
cheerSoundPlaying = false;  //same

//timer setup
hours = global.hours;
mins = global.minutes;
seconds = global.seconds;
alarm[2] = 0;               //millisecond counter

alarm[3] = 0;               //fireworks timer

/***load level***/
var file = working_directory + "Levels\Level" + string(global.selectedLevel) + ".txt";
//show_debug_message(file);

if (file_exists(file))
{
    var newLevel = file_text_open_read(file);
    
    //file is read in a specific order
    level = file_text_read_real(newLevel);
    turnCount = file_text_read_real(newLevel);
    playerRow = file_text_read_real(newLevel);
    playerCol = file_text_read_real(newLevel);
    file_text_readln(newLevel);                 //skip the row of ='s. TODO: Why does this have to be done twice?
    file_text_readln(newLevel);
    
    //level is read next
    for (var i = 0; i &lt; ds_grid_width(levelGrid); i++)
    {     
        for (var j = 0; j &lt; ds_grid_height(levelGrid); j++)
        {
           
            var num = file_text_read_real(newLevel);
            //show_debug_message(string(num)); 
            ds_grid_set(levelGrid, i, j, num);
            ds_grid_set(levelCopy, i, j, num);           
            
            //check the num and create tile at that location.
            switch(num)
            {
                
                //empty tile
                case EMPTY: 
                    ds_grid_set(tileGrid, i, j, instance_create(TILE_SIZE * j + xOffset, TILE_SIZE * i + yOffset, emptyObj));
                    //totalTiles++;
                    //tilesCrushed++;
                    break;
                    
                //normal tile
                case NORMAL:
                    ds_grid_set(tileGrid, i, j, instance_create(TILE_SIZE * j + xOffset, TILE_SIZE * i + yOffset, normalObj));
                    totalTiles++;
                    break;
                    
                //durable tile
                case 2: case 3: case 4: case 5: case 6: case 7: case 8: case 9: case 10:
                    ds_grid_set(tileGrid, i, j, instance_create(TILE_SIZE * j + xOffset, TILE_SIZE * i + yOffset, durableObj));
                    totalTiles++;
                    break;
                    
                //super tile
                case SUPER:
                    ds_grid_set(tileGrid, i, j, instance_create(TILE_SIZE * j + xOffset, TILE_SIZE * i + yOffset, superObj));
                    break;
                    
                //target
                case TARGET:
                    ds_grid_set(tileGrid, i, j, instance_create(TILE_SIZE * j + xOffset, TILE_SIZE * i + yOffset, targetObj));
                    totalTiles++;
                    break;
                    
                //chain
                case CHAIN:
                    ds_grid_set(tileGrid, i, j, instance_create(TILE_SIZE * j + xOffset, TILE_SIZE * i + yOffset, chainObj));
                    break;
            }
            
            //by default, all values in the boolGrid are false until ball lands on space
            ds_grid_set(boolGrid, i, j, false);
             
        }
        //show_debug_message('#');
    }
    
    file_text_readln(newLevel);
    file_text_readln(newLevel); //skip row of -'s
    
    //target data is read next.
    for (var i = 0; i &lt; ds_grid_width(targetGrid); i++)
    {     
        for (var j = 0; j &lt; ds_grid_height(targetGrid); j++)
        {
           
            var num = file_text_read_real(newLevel);
            //show_debug_message(string(num)); 
            ds_grid_set(targetGrid, i, j, num);
             
        }
        //show_debug_message('#');
    }
    
    file_text_close(newLevel);
}
else
{
    show_debug_message("Could not load level " + string(global.selectedLevel) + "! Level may be missing or needs to have some spaces removed.");
}

//add the ball
ball = instance_create(TILE_SIZE * playerCol + xOffset, TILE_SIZE * playerRow + yOffset, ballObj);
currentRow = ball.y;
currentCol = ball.x;

//add win/lose messages. They start off screen.
winLabel = instance_create(room_width / 2 - 200, -205, winObj);
loseLabel = instance_create(room_width / 2 - 85, -176, loseObj);

//particle effects for crushing/restoring tiles
partSystem = part_system_create();
part_system_depth(partSystem, -2);

/***crush particles***/
crushParticle = part_type_create();
part_type_shape(crushParticle, pt_shape_pixel);
part_type_size(crushParticle, 1, 3, 0, 0);
part_type_scale(crushParticle, 1, 1);
part_type_direction(crushParticle, 0, 359, 0, 10);
part_type_speed(crushParticle, 1, 3, 0, 0);
part_type_life(crushParticle, 15, 60);
part_type_gravity(crushParticle, 0.5, 270);

/*** restore particles***/
restoreParticle = part_type_create();
part_type_alpha1(restoreParticle, 0.5);
part_type_color1(restoreParticle, c_yellow);
part_type_shape(restoreParticle, pt_shape_ring);
part_type_size(restoreParticle, 3, 3, -0.2, 0);
part_type_scale(restoreParticle, 1, 1);
part_type_life(restoreParticle, 15, 15);


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//manipulate the background to produce an infinite scrolling effect
if (global.backgroundType == 0)
{
    if (global.backgroundSprite.x &gt; room_width)
    {
        global.backgroundSprite.x = -room_width + 1; //1 is added to eliminate gap between images
    }
    
    if (global.bgCopy.x &gt; room_width)
    {
        global.bgCopy.x = -room_width + 1;
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Ball movement</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//move ball in increments to simulate rolling
var destinationX = playerCol * TILE_SIZE + xOffset;
var destinationY = playerRow * TILE_SIZE + yOffset;

//if (playerMoving)
//{
    if (ball.x &lt; currentCol)
    {
        ball.x += 6;
    }
    else if (ball.x &gt; currentCol)
    {
        ball.x -= 6;
    }
    
    
    if (ball.y &lt; currentRow)
    {
        ball.y += 6;
    }
    else if (ball.y &gt; currentRow)
    {
        ball.y -= 6;
    }
//}

//ball.x = currentCol;
//ball.y = currentRow;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Win/Loss state</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//check if game is over.
if ((levelComplete || levelFailed) &amp;&amp; !timerActivated)
{
    //display win message, pause for a moment then return to level Select.
    timerActivated = true;
}


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//check if room is currently persistent. If true, we have to set the background again.  
if (room_persistent)
{
    script_execute(setBackground, global.backgroundType);
    room_persistent = false;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Tile Grid update</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//update tile grids
if (!ds_grid_get(boolGrid, playerRow, playerCol))
{
    switch(ds_grid_get(levelGrid, playerRow, playerCol))
    {
        case EMPTY:
            ds_grid_set(levelGrid, playerRow, playerCol, NORMAL);
            part_particles_create(partSystem, currentCol + (TILE_SIZE / 2), currentRow + (TILE_SIZE / 2), restoreParticle, 1);
            sound_play(tileRestore);
            tilesCrushed--;
            totalTiles++;
            if (tilesCrushed &lt; 0)
            {
                tilesCrushed = 0;   //there's a trick player can use when crush count is 0.
            }
            break;
            
        case NORMAL:
            ds_grid_set(levelGrid, playerRow, playerCol, EMPTY);
            //create particle
            part_particles_create(partSystem, currentCol + (TILE_SIZE / 2), currentRow + (TILE_SIZE / 2), crushParticle, 15);
            sound_play(tileBreak);
            tilesCrushed++;
            totalTiles--;
            global.crushTotal++;
            break;   
            
        case 2: case 3: case 4: case 5: case 6: case 7: case 8: case 9: case 10:
             //reduce tile's health
             var hp = ds_grid_get(levelGrid, playerRow, playerCol) - 1;
             ds_grid_set(levelGrid, playerRow, playerCol, hp);
             sound_play(tileClang);
             showMinusOne = true;
             minusOneLocX = currentCol + (TILE_SIZE / 2) - 16;
             minusOneLocY = currentRow + (TILE_SIZE / 2) - TILE_SIZE;
             minusOneAlpha = 1;
             alarm[1] = 0;
             break;
             
        case SUPER:
            sound_play(tileRoll);
            break;
             
        case TARGET:
            if (tilesCrushed &gt;= ds_grid_get(targetGrid, playerRow, playerCol))
            {
                ds_grid_set(levelGrid, playerRow, playerCol, EMPTY);
                part_type_color1(crushParticle, c_red);
                part_particles_create(partSystem, currentCol + (TILE_SIZE / 2), currentRow + (TILE_SIZE / 2), crushParticle, 15);
                part_type_color1(crushParticle, c_white);
                sound_play(tileBreak);
                tilesCrushed++;
                totalTiles--;
                global.crushTotal++;
            }
            else
            {
                sound_play(tileClang);  //tile not broken
            }
            break;
            
        case CHAIN:
            for (var i = 0; i &lt; MAX_ROWS; i++)
            {
                if (ds_grid_get(levelGrid, i, playerCol) == NORMAL)
                {
                    ds_grid_set(levelGrid, i, playerCol, EMPTY);
                    part_particles_create(partSystem, currentCol + (TILE_SIZE / 2), i * TILE_SIZE + yOffset + (TILE_SIZE / 2), crushParticle, 15);
                    sound_play(tileBreak);
                    tilesCrushed++;
                    totalTiles--;
                    global.crushTotal++;
                }
                else if (ds_grid_get(levelGrid, i, playerCol) == EMPTY)
                {
                     ds_grid_set(levelGrid, i, playerCol, NORMAL);
                     part_particles_create(partSystem, currentCol + (TILE_SIZE / 2), i * TILE_SIZE + yOffset + (TILE_SIZE / 2), restoreParticle, 1);
                     sound_play(tileRestore);
                     tilesCrushed--;
                     totalTiles++;
                     if (tilesCrushed &lt; 0)
                     {
                        tilesCrushed = 0;
                     }
                }
            }
            
            for (var j = 0; j &lt; MAX_COLS; j++)
            {
                if (ds_grid_get(levelGrid, playerRow, j) == NORMAL)
                {
                    ds_grid_set(levelGrid, playerRow, j, EMPTY);
                    part_particles_create(partSystem, j * TILE_SIZE + xOffset + (TILE_SIZE / 2), currentRow + (TILE_SIZE / 2), crushParticle, 15);
                    sound_play(tileBreak);
                    tilesCrushed++;
                    totalTiles--;
                    global.crushTotal++;
                }
                else if (ds_grid_get(levelGrid, playerRow, j) == EMPTY)
                {
                     ds_grid_set(levelGrid, playerRow, j, NORMAL);
                     part_particles_create(partSystem, j * TILE_SIZE + xOffset + (TILE_SIZE / 2), currentRow + (TILE_SIZE / 2), restoreParticle, 1);
                     sound_play(tileRestore);
                     tilesCrushed--;
                     totalTiles++;
                     if (tilesCrushed &lt; 0)
                     {
                        tilesCrushed = 0;
                     }
                }
            }
            break;
         
    }
    
    ds_grid_set(boolGrid, playerRow, playerCol, true);
}

//is game over?
if (totalTiles &lt;= 0)
{
    levelComplete = true;
}
else if (turnCount &lt;= 0)
{
    turnCount = 0;
    levelFailed = true;
}

        
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Timer check + file update</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>

if (timerActivated)
{
    alarm[0]++;
}

//are we leaving the level?
if (alarm[0] &gt; 120 &amp;&amp; !exitingLevel)
{
   
    exitingLevel = true;    //this is here to prevent this code block from occurring more than once.
    show_debug_message("Level finished");
    //global.levelsFinished = 100;
    //global.allLevelsComplete = true;
    
    //do more levels need to be unlocked?
    if (!global.isDemo)
    {
        if (levelComplete &amp;&amp; !global.finishedLevel[level - 1])
        {
            global.levelsFinished++;
            if (global.levelsFinished &gt; 0 &amp;&amp; global.levelsFinished &lt;= 45
            &amp;&amp; global.levelsFinished % 5 == 0 &amp;&amp; !levelsUnlocked)
            {
                //iterate through the array and unlock more levels until 5 more are unlocked
                var count = 0;
                var i = 10; //the iterator. First 10 levels are always unlocked, so no need to check them
                while (count &lt; 5 &amp;&amp; i &lt; MAX_LEVELS / 2)
                {
                    if (global.lockedLevel[i] == true)
                    {
                        //unlock level
                        global.lockedLevel[i] = false;
                        count++;
                    }
                    i++;
                }

                levelsUnlocked = true;
            }
        }
    }
    else //it's a demo, only 20 levels are unlocked max.
    {
        if (levelComplete &amp;&amp; !global.finishedLevel[level - 1])
        {
            global.levelsFinished++;
            if (global.levelsFinished &gt; 0 &amp;&amp; global.levelsFinished &lt;= 15
            &amp;&amp; global.levelsFinished % 5 == 0 &amp;&amp; !levelsUnlocked)
            {
                //iterate through the array and unlock more levels until 5 more are unlocked
                var count = 0;
                var i = 10; //the iterator. First 10 levels are always unlocked, so no need to check them
                while (count &lt; 5 &amp;&amp; i &lt; 20)
                {
                    if (global.lockedLevel[i] == true)
                    {
                        //unlock level
                        global.lockedLevel[i] = false;
                        count++;
                    }
                    i++;
                }

                levelsUnlocked = true;
            }
        }
    }
    
    //save all data
    var file = working_directory + "records.ini";
    
    if (levelComplete &amp;&amp; !global.finishedLevel[level - 1])
    {
        //add to completion
        global.finishedLevel[level - 1] = true;
        global.completionRate = global.levelsFinished / MAX_LEVELS * 100;
        
        //prevent player from completing a previously completed level to unlock levels.
        if (global.levelsFinished % 5 != 0)
        {
            levelsUnlocked = false;
        }
        
        //unlock the next set of levels if 50% are complete.
        if (global.levelsFinished &gt;= 50)
        {
            global.halfLevelsComplete = true;
        }
        
       
         
    }
    else if (levelFailed)
    {
        global.lossTotal++;
        show_debug_message("added to loss");
    }
    
    
    
    
    //timer update
    global.hours = hours;
    global.minutes = mins;
    global.seconds = seconds;
     
    script_execute(writeRecords, file);
    
    
    //leave level. If it's a demo, show splash screen if player beat all 20 levels.
    if (global.isDemo)
    {
        var k = 0;
        var demoIncomplete = false;
        while (k &lt; 20 &amp;&amp; !demoIncomplete)
        {
            if (global.finishedLevel[k] == true)
            {
                k++;
            }
            else
            {
                demoIncomplete = true;
            }
        }
        
        if (!demoIncomplete)
        {
            //show splash screen
            global.nextScreen = demoSplashScreen;
            instance_create(0, 0, screenFadeObj);
        }
        else
        {
            global.nextScreen = levelSelectScreen;
            instance_create(0, 0, screenFadeObj);
        }    
    }
    else
    {
         //go to ending screen if all levels complete. Should only occur once, but player
         //can view the ending again in the credits screen.
         if (!global.allLevelsComplete &amp;&amp; global.levelsFinished &gt;= 100)
         {
            global.allLevelsComplete = true;
            //var file = working_directory + "records.ini";
            ini_open(file);
            ini_write_real("Progress", "gameFinished", global.allLevelsComplete);
            ini_close();
            
            global.nextScreen = endingScreen;
            instance_create(0, 0, screenFadeObj);
         }
         else
         {
            global.nextScreen = levelSelectScreen;
            instance_create(0, 0, screenFadeObj);
         }
    }
    
   
}  
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//scroll the background
if (global.backgroundType == 0)
{
    global.backgroundSprite.x++;
    global.bgCopy.x++;
}

//update timer
alarm[2]++;
if (alarm[2] &gt; 59)
{
    alarm[2] = 0;
    seconds++;
    if (seconds &gt; 59)
    {
        mins++;
        seconds = 0;
        if (mins &gt; 59)
        {
            mins = 0;
            hours++;
            if (hours &gt; 99)
            {
                hours = 99;
                mins = 59;
            }
        }
    }
}

if (bgmChanged)
{
    alarm[4]++;
    if (alarm[4] &gt; 120)
    {
        alarm[4] = 121;
        bgmAlpha -= 0.05;
        if (bgmAlpha &lt;= 0)
        {
            bgmChanged = false;
            bgmAlpha = 1;
            alarm[4] = 0;
        }
    }
}

/***button check***/
if (!instance_exists(screenFadeObj) &amp;&amp; !levelFailed &amp;&amp; !levelComplete)
{
    if (mouse_check_button_released(mb_left))
    {
        //back
        if (mouse_x &gt;= backButton.x &amp;&amp; mouse_x &lt;= backButton.x + backButton.sprite_width)
        {
            if (mouse_y &gt;= backButton.y &amp;&amp; mouse_y &lt;= backButton.y + backButton.sprite_height)
            {
                sound_play(select);
                var file = working_directory + "records.ini";
                
                //did player already beat this level?
                if (!global.finishedLevel[level - 1])
                {
                    global.rageTotal++;                                     
                }
                
                //timer update
                global.hours = hours;
                global.minutes = mins;
                global.seconds = seconds;
                
                script_execute(writeRecords, file);
                
                
                global.nextScreen = levelSelectScreen;
                instance_create(0, 0, screenFadeObj);
            }
        }
        
        //tutorial
        if (mouse_x &gt;= tutorialButton.x &amp;&amp; mouse_x &lt;= tutorialButton.x + tutorialButton.sprite_width)
        {
            if (mouse_y &gt;= tutorialButton.y &amp;&amp; mouse_y &lt;= tutorialButton.y + tutorialButton.sprite_height)
            {
                sound_play(select);
                room_persistent = true; //don't kill this screen.
                global.previousScreen = gameScreen;
                global.nextScreen = tutorialScreen;
                instance_create(0, 0, screenFadeObj);
            }
        }
        
        //bgm button       
        if (mouse_x &gt;= bgmButton.x &amp;&amp; mouse_x &lt;= bgmButton.x + bgmButton.sprite_width)
        {
           if (mouse_y &gt;= bgmButton.y &amp;&amp; mouse_y &lt;= bgmButton.y + bgmButton.sprite_height)
           {
                sound_play(select);
                global.trackFile++;
                if (global.trackFile &gt;= MAX_TRACKS)
                {
                    global.trackFile = -1;  //no music
                }
                trackName = script_execute(changeBgm, global.trackFile);
                bgmChanged = true;
                alarm[4] = 0;
           }
        }
        
        //restart
        if (mouse_x &gt;= restartButton.x &amp;&amp; mouse_x &lt;= restartButton.x + restartButton.sprite_width)
        {
           if (mouse_y &gt;= restartButton.y &amp;&amp; mouse_y &lt;= restartButton.y + restartButton.sprite_height)
           {
                //simply reload the game screen, level was set previously.
                sound_play(select);
               global.nextScreen = gameScreen;
               instance_create(0, 0, screenFadeObj);
           }
        }       
    }
}

//update minusOneLoc position
if (showMinusOne)
{
   minusOneLocY--;
   alarm[1]++;
   if (alarm[1] &gt; 60)
   {
        alarm[1] = 61;
        //start fading the number
        minusOneAlpha -= 0.05;
   }
}

if (minusOneAlpha &lt;= 0)
{
    showMinusOne = false;
} 


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Ball movement code</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/***Ball movement***/

if (!instance_exists(screenFadeObj) &amp;&amp; !levelComplete &amp;&amp; !levelFailed) //so the ball can't move if transistioning to another screen
{
    if(mouse_check_button_pressed(mb_left))
    {
        //check if the player clicked on a space adjacent to the ball
        
        //right
        if (floor(mouse_x) &gt;= ball.x + TILE_SIZE &amp;&amp; floor(mouse_x) &lt;= ball.x + (TILE_SIZE * 2))
        {
            if (floor(mouse_y) &gt;= ball.y &amp;&amp; floor(mouse_y) &lt;= ball.y + TILE_SIZE)
            {
                //move ball to the right
                if (playerCol != MAX_COLS - 1 &amp;&amp; ds_grid_get(levelGrid, playerRow, playerCol + 1) &gt;= 0)
                {
                    ds_grid_set(boolGrid, playerRow, playerCol, false);
                    playerCol++;
                    currentCol = playerCol * TILE_SIZE + xOffset;
                    
                    
                    if (ds_grid_get(levelGrid, playerRow, playerCol) != SUPER)
                    {
                        turnCount--;
                    }
                    show_debug_message("Ball moving right");
                }   
            }
        }
        
        //left
        if (floor(mouse_x) &lt;= ball.x &amp;&amp; floor(mouse_x) &gt;= ball.x - TILE_SIZE)
        {
            if (floor(mouse_y) &gt;= ball.y &amp;&amp; floor(mouse_y) &lt;= ball.y + TILE_SIZE)
            {
                //move ball to the right
                if (playerCol != 0 &amp;&amp; ds_grid_get(levelGrid, playerRow, playerCol - 1) &gt;= 0)
                {
                    ds_grid_set(boolGrid, playerRow, playerCol, false);
                    playerCol--;
                    currentCol = playerCol * TILE_SIZE + xOffset;
                    
                    
                    if (ds_grid_get(levelGrid, playerRow, playerCol) != SUPER)
                    {
                        turnCount--;
                    }
                    show_debug_message("Ball moving left");
                }   
            }
        }
        
        //up
        if (floor(mouse_y) &lt;= ball.y &amp;&amp; floor(mouse_y) &gt;= ball.y - TILE_SIZE)
        {
            if (floor(mouse_x) &gt;= ball.x &amp;&amp; floor(mouse_x) &lt;= ball.x + TILE_SIZE)
            {
                //move ball up
                if (playerRow != 0 &amp;&amp; ds_grid_get(levelGrid, playerRow - 1, playerCol) &gt;= 0)
                {
                    ds_grid_set(boolGrid, playerRow, playerCol, false);
                    playerRow--;
                    currentRow = playerRow * TILE_SIZE + yOffset;
                    
                    
                    if (ds_grid_get(levelGrid, playerRow, playerCol) != SUPER)
                    {
                        turnCount--;
                    }
                    show_debug_message("Ball moving up");
                }   
            }
        }
        
        //down
        if (floor(mouse_y) &gt;= ball.y + TILE_SIZE &amp;&amp; floor(mouse_y) &lt;= ball.y + (TILE_SIZE * 2))
        {
            if (floor(mouse_x) &gt;= ball.x &amp;&amp; floor(mouse_x) &lt;= ball.x + TILE_SIZE)
            {
                //move ball up
                if (playerRow != MAX_ROWS - 1 &amp;&amp; ds_grid_get(levelGrid, playerRow + 1, playerCol) &gt;= 0)
                {
                    ds_grid_set(boolGrid, playerRow, playerCol, false);
                    playerRow++;
                    currentRow = playerRow * TILE_SIZE + yOffset;
                    
                    
                    if (ds_grid_get(levelGrid, playerRow, playerCol) != SUPER)
                    {
                        turnCount--;
                    }
                    show_debug_message("Ball moving down");
                }   
            }
        }  
        
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>win/loss animation</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//win/loss animation.
if (levelComplete)
{
    if (!soundPlaying)
    {
        sound_volume(win, 0.4);
        sound_play(win);
        soundPlaying = true;
    }
    winLabel.y += deltaY;
    
    if (winLabel.y + winLabel.sprite_height &gt; room_height / 3)
    {       
        deltaY -= 0.3;
    }
    
    if (deltaY &lt; 0)
    {
        deltaY = 0;
    }
    
    //play fireworks. Intensity increases depending on level.
    alarm[3]++;
    if (alarm[3] &gt; 30)
    {
        if (level &gt;= 50)
        {         
            if (!cheerSoundPlaying)
            {
                sound_play(bigCheer);
                sound_play(fireworks);
                cheerSoundPlaying = true;
            } 
            effect_create_above(ef_firework, floor(random(room_width)), floor(random(room_height)), 2, 
                make_colour_rgb(floor(random(256)), floor(random(256)), floor(random(256))));
        }
        
        else if (level &gt;= 30)
        {
            if (!cheerSoundPlaying)
            {
                sound_play(smallCheer);
                sound_play(fireworks);
                cheerSoundPlaying = true;
            } 
            effect_create_above(ef_firework, floor(random(room_width)), floor(random(room_height)), 1, 
                make_colour_rgb(floor(random(256)), floor(random(256)), floor(random(256))));
            
        }
        
        else if (level &gt;= 10)
        {
            if (!cheerSoundPlaying)
            {
                sound_play(smallCheer);
                cheerSoundPlaying = true;
            }
            /*sound_play(fireworks); 
            effect_create_above(ef_firework, floor(random(room_width)), floor(random(room_height)), 0, 
                make_colour_rgb(floor(random(256)), floor(random(256)), floor(random(256))));*/
        }
              
        
        alarm[3] = 0;
    }
       
}
else if (levelFailed)
{
    if (!soundPlaying)
    {
        sound_play(lose);
        soundPlaying = true;
    }
    loseLabel.y += deltaY;
    
    if (loseLabel.y + loseLabel.sprite_height &gt; room_height / 3)
    {
        deltaY -= 0.3;
    }
    
    if (deltaY &lt; 0)
    {
        deltaY = 0;
    }
}


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Alternate ball controls</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/***Ball movement***/

if (!instance_exists(screenFadeObj) &amp;&amp; !levelComplete &amp;&amp; !levelFailed) //so the ball can't move if transistioning to another screen
{
    if(keyboard_check_pressed(vk_right) || keyboard_check_pressed(ord('D')))
    {
      
        //move ball to the right
        if (playerCol != MAX_COLS - 1 &amp;&amp; ds_grid_get(levelGrid, playerRow, playerCol + 1) &gt;= 0)
        {
            ds_grid_set(boolGrid, playerRow, playerCol, false);
            playerCol++;
            currentCol = playerCol * TILE_SIZE + xOffset;
            
            
            if (ds_grid_get(levelGrid, playerRow, playerCol) != SUPER)
            {
                turnCount--;
            }
            show_debug_message("Ball moving right");
        }
    }   
           
    if(keyboard_check_pressed(vk_left) || keyboard_check_pressed(ord('A')))
    {    
       
        //move ball to the left
        if (playerCol != 0 &amp;&amp; ds_grid_get(levelGrid, playerRow, playerCol - 1) &gt;= 0)
        {
            ds_grid_set(boolGrid, playerRow, playerCol, false);
            playerCol--;
            currentCol = playerCol * TILE_SIZE + xOffset;
            
            
            if (ds_grid_get(levelGrid, playerRow, playerCol) != SUPER)
            {
                turnCount--;
            }
            show_debug_message("Ball moving left");
        }
    }   
        
    if(keyboard_check_pressed(vk_up) || keyboard_check_pressed(ord('W')))
    {     
        
       //move ball up
        if (playerRow != 0 &amp;&amp; ds_grid_get(levelGrid, playerRow - 1, playerCol) &gt;= 0)
        {
            ds_grid_set(boolGrid, playerRow, playerCol, false);
            playerRow--;
            currentRow = playerRow * TILE_SIZE + yOffset;
            
            
            if (ds_grid_get(levelGrid, playerRow, playerCol) != SUPER)
            {
                turnCount--;
            }
            show_debug_message("Ball moving up");
        }   
    }
    
    if(keyboard_check_pressed(vk_down) || keyboard_check_pressed(ord('S')))
    {   
             
        //move ball down
        if (playerRow != MAX_ROWS - 1 &amp;&amp; ds_grid_get(levelGrid, playerRow + 1, playerCol) &gt;= 0)
        {
            ds_grid_set(boolGrid, playerRow, playerCol, false);
            playerRow++;
            currentRow = playerRow * TILE_SIZE + yOffset;
                       
            if (ds_grid_get(levelGrid, playerRow, playerCol) != SUPER)
            {
                turnCount--;
            }
            show_debug_message("Ball moving down");
        }   
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//grid cleanup
if (!room_persistent)
{
    if (ds_exists(levelGrid, ds_type_grid))
    {
        show_debug_message("Cleaning up levelGrid");
        ds_grid_destroy(levelGrid);
        ds_grid_destroy(levelCopy);
        ds_grid_destroy(targetGrid);
        ds_grid_destroy(tileGrid);
        ds_grid_destroy(boolGrid);
    }
    
    if (part_system_exists(partSystem))
    {
        part_system_destroy(partSystem);
        part_type_destroy(crushParticle);
        part_type_destroy(restoreParticle);
    }
}

//sound_stop(smallCheer);
//sound_stop(bigCheer);
sound_stop(fireworks);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//grid cleanup
if (ds_exists(levelGrid, ds_type_grid))
{
    show_debug_message("Cleaning up levelGrid");
    ds_grid_destroy(levelGrid);
    ds_grid_destroy(levelCopy);
    ds_grid_destroy(targetGrid);
    ds_grid_destroy(tileGrid);
    ds_grid_destroy(boolGrid);
}

if (part_system_exists(partSystem))
{
    part_system_destroy(partSystem);
    part_type_destroy(crushParticle);
    part_type_destroy(restoreParticle);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_set_font(gameFont);
draw_set_color(c_white);
draw_text(80, 80, "Level " + string(level));
draw_text(280, 80, "Turns:");
draw_text(480, 80, "Crushed: " + string(tilesCrushed));
draw_text(680, 80, "Remaining: " + string(totalTiles));

//draw turn count in red if it's almost 0
if (turnCount &lt;= 5)
{
    draw_set_color(c_red);
    draw_text(370, 80, string(turnCount));
}
else
{   
    draw_text(370, 80, string(turnCount));
}

if (bgmChanged)
{
    draw_text_ext_color(room_width / 2 - 100, 30, "Now playing: " + trackName, 0, 600, c_lime, c_lime, c_lime, c_lime, bgmAlpha);
}


//draw timer (not to be included in release version)
//draw_set_color(c_white);
//draw_text(room_width / 2 - 100, room_height / 1.3, "Time: " + string(hours) + ":" + string(mins) + ":" + string(seconds));
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//draws the tiles + wrecking ball, plus any animations.

draw_set_font(numberFont);  //for drawing numbers on durable and target tiles.

for (var i = 0; i &lt; ds_grid_width(levelGrid); i++)
{     
    for (var j = 0; j &lt; ds_grid_height(levelGrid); j++)
    {
        switch(ds_grid_get(levelGrid, i, j))
        {
            case EMPTY:
                with(ds_grid_get(tileGrid, i, j))
                {
                    instance_change(emptyObj, 0);
                }
                break;
                
            case NORMAL:
                with(ds_grid_get(tileGrid, i, j))
                {
                    instance_change(normalObj, 0);
                    //show_debug_message("Drawing normal tile");
                }
                break;
                
            case 2: case 3: case 4: case 5: case 6: case 7: case 8: case 9: case 10:
                if (ds_grid_get(levelGrid, i, j) &lt; 2)
                {
                    with(ds_grid_get(tileGrid, i, j))
                    {
                        instance_change(normalObj, 0);
                    }
                }
                else
                {
                    //draw tile's health
                    var hp = ds_grid_get(levelGrid, i, j);
                    draw_set_color(c_blue);
                    if (hp &lt; 10)
                    {
                        draw_text(j * TILE_SIZE + xOffset + 16, i * TILE_SIZE + yOffset, string(hp));
                    }
                    else
                    {
                        draw_text(j * TILE_SIZE + xOffset + 5, i * TILE_SIZE + yOffset, string(hp));
                    }
                    
                }
                break;
                
                case TARGET:
                    //draw tile's target
                    var target = ds_grid_get(targetGrid, i, j);
                    draw_set_color(c_white);
                    if (target &lt; 10)
                    {
                        draw_text(j * TILE_SIZE + xOffset + 16, i * TILE_SIZE + yOffset, string(target));
                    }
                    else
                    {
                        draw_text(j * TILE_SIZE + xOffset + 5, i * TILE_SIZE + yOffset, string(target));
                    }
                    break;                   
        }
    }
}

if (showMinusOne)
{
    draw_set_color(c_red);
    draw_text_ext_color(minusOneLocX, minusOneLocY, "-1", 0, 30, c_red, c_red, c_red, c_red, minusOneAlpha);
}


if (levelComplete)
{
    //create fireworks, and do something
    //instance_create(room_width / 2 - 100, room_height / 2 - 51, winObj);
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
